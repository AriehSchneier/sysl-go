let sysl = //{./sysl};

let name =
    let wordRE = //re.compile(`[\p{L}_][\p{L}\p{N}_]*`);
    let trimRE = //re.compile(`^_`).sub("");
    let initialisms = {
        # https://github.com/golang/lint/blob/8f45f776aaf18cebc8d65861cc70c33c60471952/lint.go#L771
        "ACL", "API", "ASCII", "CPU", "CSS", "DNS", "EOF", "GUID", "HTML",
        "HTTP", "HTTPS", "ID", "IP", "JSON", "LHS", "QPS", "RAM", "RHS", "RPC",
        "SLA", "SMTP", "SQL", "SSH", "TCP", "TLS", "TTL", "UDP", "UI", "UID",
        "UUID", "URI", "URL", "UTF8", "VM", "XML", "XMPP", "XSRF", "XSS",
    };
    let restricted = {
        "Error",
    };
    \word
        let uppers = (wordRE.match(word) >> .(0)) >>> \i \v
            let upper = //str.upper(trimRE(v));
            cond {upper <: initialisms: upper, _: //str.title(v)};
        let result = //seq.concat(uppers);
        cond {result <: restricted: result++"_", _: result};

let asVariableName =
    \x //re.compile(`[^[:word:]]`).sub('_', //str.lower(x));

# Return a string containing the go module's main module's path. Takes
# one argument - a string specifying the location of the go.mod file to read.
# Ref: https://golang.org/ref/mod#go-mod-file-module
let goMainModulePath = \goModFilename //re.compile(`(?m)^module\s+(.*)$`).match($"${//os.file(goModFilename)}")(0)(1) rank (:.@);

# Compute the Go type for a Sysl type. If leafOnly, then
let typeImpl = \leafOnly //fn.fix(\typeImpl \t
    let ptr = cond {t('opt')?:false && !({"sequence", "set"} & (t => .@)): "*"};
    let appname = cond {!leafOnly: cond t {
        {'typeRef': {'ref': {'appname': {'part': (a: [(s: appname), ...])}, ...}, ...}, ...}: appname,
        _: "",
    }};
    let typeName = cond t {
        {'attrs': {'sensitive': {'s': (s: "true")}, ...}, ...}: `common.SensitiveString`,
        {'primitive': p, ...}: cond p {
            (s: 'DECIMAL' ): `float64`,
            (s: 'INT'     ): `int64`,
            (s: 'FLOAT'   ): `float64`,
            (s: 'STRING'  ): `string`,
            (s: 'STRING_8'): `string`,
            (s: 'BOOL'    ): `bool`,
            (s: 'BYTES'   ): `[]byte`,
            (s: 'DATE'    ): `date.Date`,
            (s: 'DATETIME'): cond t {
                {'attrs': {'time_format': {'s': (s: "stdtime")}, ...}, ...}: `time.Time`,
                _: `convert.JSONTime`,
            },
        },
        {'sequence': sequence, ...}: $`[]${typeImpl(sequence)}`,
        {'set': set, ...}: $`${typeImpl(set)}Set`,
        {'typeRef': {'ref': {'path': (a: [(s: path)]), ...ref}, ...}, ...}:
            name(//seq.join(".", [appname, path] where .@item)),
        _: name(appname),
    };
    ptr ++ typeName
);

let type = typeImpl(false);
let leafType = typeImpl(true);

let varName = //re.compile(`_`).sub("");

let package = \app
    cond app {
        {'attrs': {'go_package': {'s': (s: go_package)}, ...}, ...}: go_package,
        {'attrs': {'package': {'s': (s: package)}, ...}, ...}: //str.lower(package),
        {'name': {'part': (:a)}, ...}: //str.lower($`${a >> .s::}`),
    };

let pbPackage = \app
    {(
        alias: `pb`,
        package: cond app {
            {'attrs': {'go_pb_package': {'s': (:s)}, ...}, ...}: s,
            _: '??basepath??/???',  # TODO: what's the right package name?
        },
    )};

let pbMethodInfo = \ep
    let {'name': (s: methodName), 'param': (a: [param]), 'stmt': (a: stmts), ...} = ep;
    let {'name': (s: pname), 'type': ptype, ...} = param;
    let methodName = name(methodName);
    let last = \xs xs(xs count - 1);
    let responseType = $`${stmts
        filter .@item {{'ret': _, ...}: .}
        >> last(//seq.split(".", //seq.split(" ", .("ret")("payload").s)(2)))
    ::}`;
    let requestType = leafType(ptype) || type(ptype); # FIXME unsure if this is correct, this failed until the fallback using type(ptype) was added.
    (
        name: methodName,
        :pname,
        :requestType,
        :responseType,
        sig: \package \opts
            let opts = cond {opts: `opts ...grpc.CallOption,`};
            $`
                (
                    ctx context.Context,
                    ${pname} *${package}.${requestType},
                    ${opts}
                ) (*${package}.${responseType}, error)
            `,
    );

let typeWithPackage = \type \module
    cond type {
        [t]: name(t),
        [app, ...t]: $`${package(module('apps')(app))}.${t >> name(.)::.}`,
    };

let prelude = \app \imports $`
    // Code generated by sysl DO NOT EDIT.
    package ${package(app)}

    import (
        "context"
        "database/sql"
        "encoding/json"
        "flag"
        "fmt"
        "log"
        "net/http"
        "net/url"

        "github.com/anz-bank/sysl-go/catalogservice"
        "github.com/anz-bank/sysl-go/common"
        "github.com/anz-bank/sysl-go/core"
        "github.com/anz-bank/sysl-go/config"
        "github.com/anz-bank/sysl-go/convert"
        "github.com/anz-bank/sysl-go/database"
        "github.com/anz-bank/sysl-go/handlerinitialiser"
        "github.com/anz-bank/sysl-go/restlib"
        "github.com/anz-bank/sysl-go/validator"
        "github.com/anz-bank/sysl-go/core/authrules"

        ${
            imports => cond . {
                (:alias, package: pkg): $`${alias} ${pkg:q}`,
                _: $`${.:q}`,
            } orderby .
        ::\i:\n}
        pkglog "github.com/anz-bank/pkg/log"
        "github.com/go-chi/chi"
        "github.com/rickb777/date"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "gopkg.in/yaml.v2"
    )`;

let methodName =
    # TODO: Remove these warts.
    let hasArg = //re.compile(`\{(\p{L}+)\}$`).match;
    let hasList = //re.compile(`[\p{L}\p{N}]$`).match; # TODO: Should be \[...\]
    \ep
        cond ep {
            {'restParams': {'method': (s: method), 'path': (s: path), ...r}, ...m}:
                let vars_in_url_name = "vars_in_url_name" <: sysl.patterns(ep);
                let withArg = cond {hasArg(path) && //str.upper(method) = "POST": "WithArg"};
                let getList = cond {hasList(path) && //str.upper(method) = "GET": "List"};
                let methodPostfix = //seq.split("/")(//seq.trim_prefix("/", path)) >>
                    let postfix = cond hasArg(.) {
                        [[_, arg]]: cond {vars_in_url_name: arg},
                        _: .,
                    };
                    //str.title(//str.lower(postfix));
                name(//str.title(//str.lower(method)) ++ $"${methodPostfix::}") ++ withArg ++ getList,
            {'name': (:s), ...}:
                name(s),
        };

let errorReturnTypes = \app
    //rel.union(app('endpoints')?:{} => (sysl.endpoint.returns(.@value) => .@item))
        where .var = "error" && .type != [""] => //seq.join(".")(.type) => name(.);

let module = \module
    let typeWithClientPackage = \(:type, :seq, ...)
        let pkgnames = type => .@item;
        let packages = module('apps') where .@ <: pkgnames;
        cond {
            packages: $`${cond {seq: "[]"}}${package((packages single).@value)}.${name(type(1))}`,
            type = ["ok"]: "",
            _: $`${cond{seq: `[]`}}` ++ name(//seq.concat(type)),
        };

    let targetApp = \target
        ((module('apps') where .@value('name') = target) single).@value;

    let methodSignature =
        let isError = //re.compile(`\berror\b`).match;
        \ep
            $`${methodName(ep)}(ctx context.Context, req *${methodName(ep)}Request) ${
                let tn = sysl.endpoint.returns(ep) => .@item where .var != "error" => \t
                    # TODO: Remove double entry once cond array handling is fixed.
                    cond t.type {
                        ([""], [""]): "*http.Header",
                        _: $"*${typeWithClientPackage(t)}",
                    };
                cond tn {
                    {}: "error",
                    _: $`(${(tn orderby .) ++ ["error"]::, })`,
                }

            }`;

    let callSignature = \{'target': target, 'endpoint': ep, ...}
        let dep = targetApp(target);
        let package = package(dep);
        let ep = sysl.app.endpoint(dep, ep.s);
        let method = methodName(ep);
        cond {
            'gRPC' <: sysl.patterns(dep):
                pbMethodInfo(ep) -> $`${name(package)}${.name} func${.sig(package, true)}`,
            _:
                $`
                    ${name(package)}${method} func(
                        ctx context.Context,
                        req *${package}.${method}Request,
                    ) (${
                        let typed = sysl.endpoint.normalReturns(ep)
                            >> $`*${cond{.seq: `[]`}}${package}.${//seq.join(".", .type)}`;
                        let untyped = sysl.endpoint.untypedReturns(ep) >> `*http.Header`;
                        typed ++ untyped ++ ["error"]
                    ::, })
                `,
        };

    let clientDeps = \eps
        //rel.union(eps => \(@item: (@value: ep, ...), ...)
            sysl.endpoint.calls(ep) => \(@:_, @item: {'target': target, ...}) (
                :target,
                import: package(targetApp(target)),
                pbImport: pbPackage(targetApp(target)),
                app: (name: targetApp(target, 'name')),
            ));

    let depField = \(:import, :target, ...)
        let grpc = 'gRPC' <: sysl.patterns(targetApp(target));
        (
            :grpc,
            name: $`${import}Service`,
            type: $`${import}.Service`,
        );

    (
        :callSignature,
        :clientDeps,
        :depField,
        :methodSignature,
        :targetApp,
        :typeWithClientPackage,
    );

(
    :goMainModulePath,
    :methodName,
    :module,
    :name,
    :package,
    :pbPackage,
    :pbMethodInfo,
    :prelude,
    :type,
    :leafType,
    :typeWithPackage,
    :varName,
    :errorReturnTypes,
    :asVariableName,
)
