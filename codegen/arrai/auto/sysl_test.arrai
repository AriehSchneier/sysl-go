let sysl= //{./sysl};

# The following demo app model was generated by
# pb --mode json from the input sysl model:
#
# Service :
#     Dance(DanceRequest):
#         IF unlikely:
#           Backend <- POST /alpha
#         While false:
#           Backend <- GET /beta
#         Backend <- PUT /gamma
#         alt condition one:
#           Backend <- PUT /delta
#         alt condition two:
#           alt condition hi:
#             Fallback <- POST /kappa
#             Fallback <- nu
#             Fallback <- mu
#           alt condition lo:
#             Backend <- rho
#             if impossible:
#               Backend <- sigma
#             For each foo in the barr:
#               Backend <- tau
#         return ok

let demoModel = <<('{
 "apps": {
  "Service": {
   "name": {
    "part": [
     "Service"
    ]
   },
   "endpoints": {
    "Dance": {
     "name": "Dance",
     "param": [
      {
       "name": "DanceRequest",
       "type": {
        "noType": {}
       }
      }
     ],
     "stmt": [
      {
       "cond": {
        "test": "unlikely",
        "stmt": [
         {
          "call": {
           "target": {
            "part": [
             "Backend"
            ]
           },
           "endpoint": "POST /alpha"
          }
         }
        ]
       }
      },
      {
       "loop": {
        "mode": "WHILE",
        "criterion": "false",
        "stmt": [
         {
          "call": {
           "target": {
            "part": [
             "Backend"
            ]
           },
           "endpoint": "GET /beta"
          }
         }
        ]
       }
      },
      {
       "call": {
        "target": {
         "part": [
          "Backend"
         ]
        },
        "endpoint": "PUT /gamma"
       }
      },
      {
       "group": {
        "title": "alt condition one",
        "stmt": [
         {
          "call": {
           "target": {
            "part": [
             "Backend"
            ]
           },
           "endpoint": "PUT /delta"
          }
         }
        ]
       }
      },
      {
       "group": {
        "title": "alt condition two",
        "stmt": [
         {
          "group": {
           "title": "alt condition hi",
           "stmt": [
            {
             "call": {
              "target": {
               "part": [
                "Fallback"
               ]
              },
              "endpoint": "POST /kappa"
             }
            },
            {
             "call": {
              "target": {
               "part": [
                "Fallback"
               ]
              },
              "endpoint": "nu"
             }
            },
            {
             "call": {
              "target": {
               "part": [
                "Fallback"
               ]
              },
              "endpoint": "mu"
             }
            }
           ]
          }
         },
         {
          "group": {
           "title": "alt condition lo",
           "stmt": [
            {
             "call": {
              "target": {
               "part": [
                "Backend"
               ]
              },
              "endpoint": "rho"
             }
            },
            {
             "cond": {
              "test": "impossible",
              "stmt": [
               {
                "call": {
                 "target": {
                  "part": [
                   "Backend"
                  ]
                 },
                 "endpoint": "sigma"
                }
               }
              ]
             }
            },
            {
             "foreach": {
              "collection": "foo in the barr",
              "stmt": [
               {
                "call": {
                 "target": {
                  "part": [
                   "Backend"
                  ]
                 },
                 "endpoint": "tau"
                }
               }
              ]
             }
            }
           ]
          }
         }
        ]
       }
      },
      {
       "ret": {
        "payload": "ok"
       }
      }
     ],
     "sourceContext": {
      "file": "gateway.sysl",
      "start": {
       "line": 2,
       "col": 4
      },
      "end": {
       "line": 23
      }
     }
    }
   },
   "sourceContext": {
    "file": "gateway.sysl",
    "start": {
     "line": 1,
     "col": 1
    },
    "end": {
     "line": 1
    }
   }
  }
 }
}')>>;

let demoEndpoint = //encoding.json.decode(demoModel)("apps")("Service")("endpoints")("Dance");
let demoEndpointExpectedCalls = {
    "POST /alpha",
    "GET /beta",
    "PUT /gamma",
    "PUT /delta",
    "POST /kappa",
    "mu",
    "nu",
    "rho",
    "sigma",
    "tau",
};

let modelWithStatementlessEndpoint = <<('{
 "apps": {
  "A": {
   "name": {
    "part": [
     "A"
    ]
   },
   "attrs": {
    "package": {
     "s": "a"
    }
   },
   "endpoints": {
    "Buzz": {
     "name": "Buzz",
     "sourceContext": {
      "file": "specs/a.sysl",
      "start": {
       "line": 3,
       "col": 4
      },
      "end": {
       "line": 3,
       "col": 10
      }
     }
    }
   },
   "sourceContext": {
    "file": "specs/a.sysl",
    "start": {
     "line": 1,
     "col": 1
    },
    "end": {
     "line": 1
    }
   }
  }
 }
}')>>;
let statementlessEndpoint = //encoding.json.decode(modelWithStatementlessEndpoint)("apps")("A")("endpoints")("Buzz");
let statementlessEndpointExpectedCalls = {};

(
    endpointCallDiscovery: //test.assert.equal(demoEndpointExpectedCalls)(sysl.endpoint.calls(demoEndpoint) => .@item('endpoint').s),
    endpointWithNoStatements: //test.assert.equal(statementlessEndpointExpectedCalls)(sysl.endpoint.calls(statementlessEndpoint) => .@item('endpoint').s),
)
