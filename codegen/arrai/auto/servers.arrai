\fixPBPath \config \apps
    let (:basepath, :module, app: mainApp, ...)   = config;
    let generate                                  = //{./generate};
    let (:package, ...)                           = //{./go};
    let (:patterns, app: appUtil, ...) = //{./sysl};
    let type                                      = cond {'gRPC' <: patterns(mainApp): 'grpc-app', _: 'rest-app'};

    let isGRPCClient =
        let appsUsedByMainApp =
            appUtil.dependenciesWithSource(mainApp) where (.src <: {'param', 'return'}) => .app('part');
        \client
            ('gRPC' <: patterns(client)) ||
            # if main app is gRPC and the client app's type is used by main app in endpoints, then treat client as gRPC
            (type = 'grpc-app' && client('name', 'part') <: appsUsedByMainApp)
    ;

    (
        ifExists: 'replace',
        dir:
            generate.generate(config, generate.groups(type))
            +> ((
                apps => \(@: _, @value: app)
                    let config = generate.config((:basepath, :module, :app, :fixPBPath));
                    let type = cond { isGRPCClient(app): 'grpc-client', _: 'rest-client' };
                    # if app is grpc client and it does not have endpoints, do not generate.
                    let shouldGenerate = cond type {'grpc-client': app('endpoints')?:false, _: true};
                    shouldGenerate && (@: package(app), @value: generate.generate(config, generate.groups(type)))
            ) where .),
    )
